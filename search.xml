<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode Daily 20250801-20250806</title>
      <link href="/2025/08/01/leetcode-daily-20250801-20250806/"/>
      <url>/2025/08/01/leetcode-daily-20250801-20250806/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>20250801到20250806 Leetcode每日一题的记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用Java解题</p><span id="more"></span><h1 id="118-杨辉三角">118. 杨辉三角</h1><p>20250801<br><a href="https://leetcode.cn/problems/pascals-triangle/description/?envType=daily-question&amp;envId=2025-08-01">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/pascals-triangle/solutions/510638/yang-hui-san-jiao-by-leetcode-solution-lew9">官方题解</a></p><h2 id="思路">思路</h2><p>可以对应到组合数公式</p><p><span class="markdown-them-math-inline">$\begin{pmatrix}C_{0}^{0} = 1 &amp;  &amp;  &amp; \\C_{1}^{0} = 1 &amp; C_{1}^{1} = \frac{1}{1} =1 &amp; &amp; \\C_{2}^{0} = 1 &amp; C_{2}^{1} = \frac{2}{1}=2 &amp; C_{2}^{2} = \frac{2 \times 1}{1 \times 2} = 1 &amp; \\C_{3}^{0} = 1 &amp; C_{3}^{1} = \frac{3}{1}=3 &amp; C_{3}^{2} = \frac{3 \times 2}{1 \times 2}=3 &amp; C_{3}^{3} = \frac{3 \times 2 \times 1}{1 \times 2 \times 3} = 1\end{pmatrix}$</span></p><h2 id="复杂度">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N^2)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不计返回值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(1)$</span></li></ul><h2 id="代码">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;            List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;            t.add(<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;                a = a * (i + <span class="hljs-number">1</span> - j) / j;                t.add(a);            &#125;            ans.add(t);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="2561-重排水果">2561. 重排水果</h1><p>20250802<br><a href="https://leetcode.cn/problems/rearranging-fruits/description/?envType=daily-question&amp;envId=2025-08-02">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/rearranging-fruits/solutions/3729209/zhong-pai-shui-guo-by-leetcode-solution-9z2g">官方题解</a></p><p>执行时间前排代码</p><h2 id="思路-1">思路</h2><p>贪心</p><p>显然如果某个值出现了奇数次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么无法使两个<code>basket</code>相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$freq_{1} + freq_{2}$</span>为奇数 <span class="markdown-them-math-inline">$\Leftrightarrow$</span> <span class="markdown-them-math-inline">$freq_{1} - freq_{2}$</span>为奇数</p><p>尽可能用小的值交换尽可能大的值</p><p>对于两个要交换的值存在间接交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><p><span class="markdown-them-math-inline">$basket1 = [8_{1}, 50_{1}, 50_{2}]$</span><br><span class="markdown-them-math-inline">$basket2 = [8_{2}, 100_{1}, 100_{2}]$</span></p><p>直接交换需要<code>min(50, 100) = 50</code></p><p>间接交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ol><li>交换<span class="markdown-them-math-inline">$8_{1}$</span>和<span class="markdown-them-math-inline">$100_{1}$</span>得到<br><span class="markdown-them-math-inline">$basket1 = [100_{1}, 50_{1}, 50_{2}]$</span><br><span class="markdown-them-math-inline">$basket2 = [8_{2}, 8_{1}, 100_{2}]$</span></li><li>交换<span class="markdown-them-math-inline">$8_{1}$</span>和<span class="markdown-them-math-inline">$50_{1}$</span>得到<br><span class="markdown-them-math-inline">$basket1 = [100_{1}, 8_{1}, 50_{2}]$</span><br><span class="markdown-them-math-inline">$basket2 = [8_{2}, 50_{1}, 100_{2}]$</span><br>需要<code>min(8, 100) + min(8, 50) = 2 * 8 = 16</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>间接交换更优</li></ol><p>先用<code>Map</code>统计<code>basket1</code>中值的个数与<code>basket2</code>中值的个数的差值</p><ul><li><code>value</code>为负数代表当前值在<code>basket2</code>中出现的次数多</li><li><code>value</code>为正数代表当前值在<code>basket1</code>中出现的次数多</li><li>如果为<code>0</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示当前值在<code>basket1</code>和<code>basket2</code>中出现的次数相等</li></ul><p>对于<code>key1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果它的值为<code>2</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么存在一个<code>key2</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的值为<code>-2</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将一个<code>key1</code>与<code>key2</code>交换后它们的值都归零<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也就是<code>basket1</code>和<code>basket2</code>有相同个数的<code>key1</code>和<code>key2</code></p><p>然后将<code>Map</code>转换为列表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将<span class="markdown-them-math-inline">$\frac{value}{2}$</span>个<code>key</code>加入列表中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于每个<code>key</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于会选择尽可能小的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先将列表从小到大排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于前一半的值在后一半中必定存在与它正负相反的值<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>列表中一半的值对应<code>Map</code>中的<code>value</code>为正<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>另一半为负<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前一半为相对较小的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此结果只需要考虑前一半的值即可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>另外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前的值大于<code>2 * minv</code><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>minv</code>为全部<code>key</code>的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于间接交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么使用间接交换更优</p><h2 id="复杂度-1">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>瓶颈在排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(n\log{n})$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>Map</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li></ul><h2 id="其他">其他</h2><p>这里使用<code>Map.merge()</code>更新<code>Map</code>中的值更快</p><p><code>m1.merge(i, 1, Integer::sum);</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>i</code>为<code>key</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>1</code>为<code>更新的值</code>,<code>Integer::sum</code>是<code>lambda</code>表达式</p><ul><li>如果<code>i</code>不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<code>m1.put(i, 1)</code></li><li>如果<code>i</code>存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<code>m1.put(i, m1.get(i) + 1)</code></li></ul><p>绝对值<code>Math.abs(i)</code></p><p><code>entry</code>枚举<code>Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()</code></p><h2 id="代码-1">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] basket1, <span class="hljs-keyword">int</span>[] basket2)</span> </span>&#123;        Map&lt;Integer, Integer&gt; m1 = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">long</span> minv = Long.MAX_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : basket1) &#123;            m1.merge(i, <span class="hljs-number">1</span>, Integer::sum);            minv = Math.min(i, minv);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : basket2) &#123;            m1.merge(i, -<span class="hljs-number">1</span>, Integer::sum);            minv = Math.min(i, minv);        &#125;                List&lt;Integer&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : m1.entrySet()) &#123;            <span class="hljs-keyword">if</span> (entry.getValue() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Math.abs(entry.getValue()) / <span class="hljs-number">2</span>; i++) &#123;                l.add(entry.getKey());            &#125;        &#125;        Collections.sort(l);        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l.size() / <span class="hljs-number">2</span>; i++) &#123;            ans += Math.min(<span class="hljs-number">2</span> * minv, l.get(i));        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Daily 20250725-20250731</title>
      <link href="/2025/07/30/leetcode-daily-20250725-20250731/"/>
      <url>/2025/07/30/leetcode-daily-20250725-20250731/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Leetcode 20250725-20250731每日一题的记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用Java解题</p><span id="more"></span><h1 id="3487-删除后的最大子数组元素和">3487. 删除后的最大子数组元素和</h1><p>20250725<br><a href="https://leetcode.cn/problems/maximum-unique-subarray-sum-after-deletion/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>执行用时前排代码</p><h2 id="思路">思路</h2><p>将大于等于<code>0</code>的数字加入<code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时统计小于<code>0</code>的数字的最大值</p><p>最终如果<code>HashSet</code>非空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求<code>HashSet</code>所有元素的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>返回小于<code>0</code>的数字的最大值</p><h2 id="复杂度">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历一遍数组+<code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li></ul><h2 id="其他">其他</h2><p>Java int最大值和最小值<br><code>int a = Integer.MAX_VALUE;</code>,<code>int b = Integer.MIN_VALUE;</code></p><h2 id="优化">优化</h2><p>题目数据范围<span class="markdown-them-math-inline">$-100\leq nunms[i] \leq100$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用一个<code>boolean</code>数组储存当前数字是否出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历时更新状态</p><h2 id="代码">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> t = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) &#123;            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; !set.contains(i)) &#123;                set.add(i);                ans += i;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> &amp;&amp; i &gt; t) &#123;                t = i;            &#125;        &#125;        <span class="hljs-keyword">if</span> (set.isEmpty()) &#123;            <span class="hljs-keyword">return</span> t;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> ans;        &#125;    &#125;&#125;</code></pre></div><p>优化后</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">boolean</span>[] hasn = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">102</span>];        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> t = Integer.MIN_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) &#123;            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (!hasn[i]) &#123;                    hasn[i] = <span class="hljs-keyword">true</span>;                    ans += i;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                t = Math.max(t, i);            &#125;        &#125;        <span class="hljs-keyword">if</span> (ans == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> t;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="3480-删除一个冲突对后最大子数组数目">3480. 删除一个冲突对后最大子数组数目</h1><p>20250726<br><a href="https://leetcode.cn/problems/maximize-subarrays-after-removing-one-conflicting-pair/description/">题目链接</a></p><h2 id="todo">TODO</h2><hr><h1 id="2210-统计数组中峰和谷的数量">2210. 统计数组中峰和谷的数量</h1><p>20250727<br><a href="https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/solutions/1352602/by-endlesscheng-59gn">灵茶山艾府</a></p><h2 id="思路-1">思路</h2><p>用一个<code>l</code>数组存当前数字左边的不相等元素的下标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用一个<code>r</code>数组存当前数字右边不相等元素的下标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>l[0] = - 1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>r[n - 1] = n</code></p><p>从下标<code>1</code>开始遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前元素与前一个元素不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且满足当前元素大于<code>l[i]</code>下标和<code>r[i]</code>下标的元素或者小于<code>l[i]</code>下标和<code>r[i]</code>下标的元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数量加<code>1</code></p><h2 id="复杂度-1">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>l</code>和<code>r</code>数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li></ul><h2 id="优化1">优化1</h2><p>将连续相同元素压缩为<code>1</code>个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在原数组内操作</p><p>遍历去重后的数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前元素同时大于左右或者同时小于左右相邻元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则数量加<code>1</code></p><h2 id="优化2">优化2</h2><p>用<code>3</code>个指针分别表示左边最近不相等邻居<code>pre</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前元素<code>cur</code>和右边最近不相等邻居<code>nxt</code></p><p>遍历时使<code>nxt</code>为<code>cur</code>后第<code>1</code>个元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果<code>nxt</code>与<code>cur</code>对应元素相等则<code>cur</code>向后遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>如果相等时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>判断<code>cur</code>对应元素是否同时大于<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>小于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span><code>pre</code>和<code>nxt</code>对应元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果满足则答案加<code>1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新<code>pre</code>为<code>cur</code></p><p>由于初始化时<code>pre</code>为<code>0</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>cur</code>为<code>1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以要判断<code>pre</code>是否与<code>cur</code>相等</p><h2 id="代码-1">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countHillValley</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] l = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        <span class="hljs-keyword">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        l[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;                l[i] = l[i - <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                l[i] = i - <span class="hljs-number">1</span>;            &#125;        &#125;        r[nums.length - <span class="hljs-number">1</span>] = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;                r[i] = r[i + <span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span> &#123;                r[i] = i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (l[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; r[i] &lt; nums.length) &#123;                <span class="hljs-keyword">if</span> (nums[l[i]] &gt; nums[i] &amp;&amp; nums[r[i]] &gt; nums[i] &amp;&amp; nums[i] != nums[i - <span class="hljs-number">1</span>]) &#123;                    ans++;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[l[i]] &lt; nums[i] &amp;&amp; nums[r[i]] &lt; nums[i] &amp;&amp; nums[i] != nums[i - <span class="hljs-number">1</span>]) &#123;                    ans++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><p>优化1</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countHillValley</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != nums[i - <span class="hljs-number">1</span>]) &#123;                nums[l++] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> ((nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) == (nums[i] &gt; nums[i + <span class="hljs-number">1</span>])) &#123;                ans++;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><p>优化2</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countHillValley</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pre = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> cur = nums[i];            <span class="hljs-keyword">int</span> nxt = nums[i + <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (cur == nxt) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (!(pre == cur) &amp;&amp; (cur &gt; pre) == (cur &gt; nxt)) &#123;                ans++;            &#125;            pre = cur;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="2044-统计按位或能得到最大值的子集数目">2044. 统计按位或能得到最大值的子集数目</h1><p>20250728<br><a href="https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solutions/1335667/tong-ji-an-wei-huo-neng-de-dao-zui-da-zh-r6zd">官方题解</a></p><p>执行用时前排代码</p><h2 id="思路-2">思路</h2><p>整个数组所有元素按位或一定是最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先求出最大值</p><p>二进制压缩状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前子集所有元素按位或等于最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>答案加<code>1</code></p><h2 id="复杂度-2">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>全部子集<span class="markdown-them-math-inline">$2^{n}$</span>个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>平均每个子集元素个数与<code>n</code>线性相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体复杂度<span class="markdown-them-math-inline">$O(2^{N} \times N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$O(1)$</span></li></ul><h2 id="优化-1">优化</h2><p>DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从下标为<code>0</code>开始递归<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前的值已经等于最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则答案加上<span class="markdown-them-math-inline">$2^{n - i}$</span>并返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意递归到数组最后一个元素返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一层递归选择是否将当前元素加入子集</p><p>优化后的时间复杂度为<span class="markdown-them-math-inline">$O(2^{n})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>空间复杂度为<span class="markdown-them-math-inline">$O(N)$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>搜索深度最多为<code>n</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p><h2 id="代码-2">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countMaxOrSubsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxv = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            maxv = maxv | nums[i];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); i++) &#123;            <span class="hljs-keyword">int</span> tem = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;                    tem = tem | nums[j];                &#125;            &#125;            <span class="hljs-keyword">if</span> (tem == maxv) &#123;                cnt++;            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;</code></pre></div><p>优化后</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> cnt;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countMaxOrSubsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxv = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            maxv = maxv | nums[i];        &#125;        cnt = <span class="hljs-number">0</span>;        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, maxv, nums);        <span class="hljs-keyword">return</span> cnt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> ma, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (sum == ma) &#123;            cnt += <span class="hljs-number">1</span> &lt;&lt; (nums.length - i);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (i == nums.length) &#123;            <span class="hljs-keyword">return</span>;        &#125;        dfs(i + <span class="hljs-number">1</span>, sum, ma, nums);        dfs(i + <span class="hljs-number">1</span>, sum | nums[i], ma, nums);    &#125;&#125;</code></pre></div><hr><h1 id="2411-按位或最大的最小子数组长度">2411. 按位或最大的最小子数组长度</h1><p>20250729<br><a href="https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/description/">题目链接</a></p><h2 id="思路-3">思路</h2><p>数字最大是<span class="markdown-them-math-inline">$10^{9}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不会大于<span class="markdown-them-math-inline">$(2^{10})^{3}=2^{30}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以用一个长度为<code>31</code>的数组<code>bt</code>表示当前位的&quot;<code>1</code>&quot;的个数</p><p>从后向前遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前元素对应<code>bt</code>数组中为<code>1</code>的位加<code>1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>滑动窗口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果删除窗口结尾元素后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>bt</code>数组不存在某个元素归零<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以删除当前元素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>继续向前滑动窗口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果存在某个元素归零<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则表示当前子数组按位或距离最大值缺了某一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不可以向前滑动窗口</p><h2 id="复杂度-3">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对于每一个二进制数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>统计它的每一位需要<span class="markdown-them-math-inline">$O(\log{C})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>C</code>为二进制数最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总体为<span class="markdown-them-math-inline">$O(N\log{C})$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不算返回值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(\log{C})$</span></li></ul><h2 id="todo-$o(n)$优化">TODO <span class="markdown-them-math-inline">$O(N)$</span>优化</h2><h2 id="代码-3">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestSubarrays(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span>[] bt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">31</span>];        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span> p = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, t = nums[i]; t &gt; <span class="hljs-number">0</span>; j++, t = t &gt;&gt; <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">if</span> ((t &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;                    bt[j]++;                &#125;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = p; j &gt; i; j--) &#123;                <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, t = nums[j]; t &gt; <span class="hljs-number">0</span>; k++, t = t &gt;&gt; <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">if</span> ((t &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">if</span> (bt[k] == <span class="hljs-number">1</span>) &#123;                            flag = <span class="hljs-keyword">false</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (flag) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, t = nums[j]; t &gt; <span class="hljs-number">0</span>; k++, t = t &gt;&gt; <span class="hljs-number">1</span>) &#123;                        <span class="hljs-keyword">if</span> ((t &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;                            bt[k]--;                        &#125;                    &#125;                    p--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            ans[i] = p - i + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="2419-按位与最大的最长子数组">2419. 按位与最大的最长子数组</h1><p>20250730<br><a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>执行用时前排代码</p><h2 id="思路-4">思路</h2><p>数组中的最大值与小于它的数取与必然减小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此题目换句话说是求最大值连续最长长度</p><p>先求出最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后统计与最大值相等的连续序列的长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并求序列长度的最大值</p><h2 id="复杂度-4">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组<span class="markdown-them-math-inline">$O(N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$O(1)$</span></li></ul><h2 id="优化-2">优化</h2><p>一次遍历的方法</p><p>滑动窗口取元素相等的序列的左右端点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前序列的元素大于最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则更新最大值和答案长度为当前窗口长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果当前序列的元素等于最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则取当前序列长度与之前答案长度的最大值</p><h2 id="代码-4">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> m = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            m = Math.max(m, nums[i]);        &#125;        <span class="hljs-keyword">int</span> tem = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (m == nums[i] &amp;&amp; m == nums[i - <span class="hljs-number">1</span>]) &#123;                tem++;            &#125; <span class="hljs-keyword">else</span> &#123;                ans = Math.max(ans, tem);                tem = <span class="hljs-number">1</span>;            &#125;        &#125;        ans = Math.max(ans, tem);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><p>优化后</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> m = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> tem = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; n) &#123;            j = i;            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; nums[j] == nums[i]) &#123;                j++;            &#125;            <span class="hljs-keyword">if</span> (nums[i] &gt; m) &#123;                m = nums[i];                ans = j - i;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == m) &#123;                ans = Math.max(ans, j - i);            &#125;            i = j;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="2683-相邻值的按位异或">2683. 相邻值的按位异或</h1><p>20250731<br><a href="https://leetcode.cn/problems/neighboring-bitwise-xor/description/?envType=daily-question&amp;envId=2025-07-31">题目链接</a></p><h2 id="思路-5">思路</h2><ul><li>如果<span class="markdown-them-math-inline">$a \oplus b = c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$a \oplus c = b$</span></li></ul><p><span class="markdown-them-math-inline">$o[0] \oplus o[1] = d[0]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以假设<code>o[0]</code>等于<code>d[0]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此<span class="markdown-them-math-inline">$o[1] = o[0] \oplus d[0]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$o[2] = o[1] \oplus d[1]$</span><br>…<span class="markdown-them-math-inline">$o[n - 1] = o[n - 2] \oplus d[n - 2]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$o[0](expected) = o[n - 1] \oplus d[n - 1]$</span></p><p>最后判断<code>o[0](expected)</code>与<code>o[0]</code>是否相等即可</p><h2 id="复杂度-5">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$O(1)$</span></li></ul><h2 id="代码-5">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doesValidArrayExist</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] derived)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = derived[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; derived.length; i++) &#123;            a = a ^ derived[i];        &#125;        <span class="hljs-keyword">return</span> a == derived[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><hr><p>如有错误欢迎批评指正</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Daily 20250718-20250724</title>
      <link href="/2025/07/24/leetcode-daily-20250718-20250724/"/>
      <url>/2025/07/24/leetcode-daily-20250718-20250724/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Leetcode 20250718到20250724每日一题的记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用Java解题</p><span id="more"></span><h1 id="2163-删除元素后和的最小差值">2163. 删除元素后和的最小差值</h1><p>20250718<br><a href="https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/solutions/1249409/shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j">官方题解</a></p><h2 id="思路">思路</h2><p>为了使前<span class="markdown-them-math-inline">$n$</span>个数减后<span class="markdown-them-math-inline">$n$</span>个数的差值最小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要使前<span class="markdown-them-math-inline">$n$</span>个数尽可能小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后<span class="markdown-them-math-inline">$n$</span>个数尽可能大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>在前<span class="markdown-them-math-inline">$n + i$</span>个数中去掉<span class="markdown-them-math-inline">$i$</span>个最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>后<span class="markdown-them-math-inline">$2n - i$</span>个数中去掉<span class="markdown-them-math-inline">$n - i$</span>个最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(<span class="markdown-them-math-inline">$0 \leq i \leq n$</span>)</p><p>维护一个数组代表当前<span class="markdown-them-math-inline">$i$</span>下前面数组和的最小值</p><p>用大顶堆将前<span class="markdown-them-math-inline">$n$</span>个元素入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>向后遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于之后的每一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果小于当前最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将最大值出堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将这个数入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新当前和的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果大于当前最大值则不用操作,和的最小值不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>用小顶堆将后<span class="markdown-them-math-inline">$n$</span>个元素入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>向前遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于之后的每一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果大于当前最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将最小值出堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将这个数入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新当前和的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果小于当前最小值则不用操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>和的最大值不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>实现时这里可以开始更新结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>取上面对应下标的最小值数组与当前和的最大值的差的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不用再用一个数组存最大值了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p><h2 id="java-大顶堆(优先队列)">Java 大顶堆(优先队列)</h2><div class="highlight"><pre class="code"><code>PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(n, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a,Integer b)</span> </span>&#123;                <span class="hljs-keyword">return</span> b - a;            &#125;        &#125;); <span class="hljs-comment">//优先队列</span></code></pre></div><h2 id="优先队列相关操作">优先队列相关操作</h2><ul><li><code>pq.offer(i)</code>元素入堆<ul><li>与<code>pq.add(i)</code>的区别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>向满的队列加元素时<code>pq.offer(i)</code>会返回<code>false</code>,<code>pq.add(i)</code>会抛出异常</li></ul></li><li><code>pq.poll()</code>元素出堆并返回当前最大<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>值<ul><li>与<code>pq.remove()</code>的区别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>向空的队列删元素时<code>pq.poll()</code>会返回<code>null</code>,<code>pq.remove()</code>会抛出异常</li></ul></li><li><code>pq.peek()</code>返回当前最大<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>值<ul><li>与<code>pq.element()</code>的区别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>向空的队列删元素时<code>pq.peek()</code>会返回<code>null</code>,<code>pq.element()</code>会抛出异常</li></ul></li></ul><h2 id="其他">其他</h2><p><code>Math.max(a, b)</code>求2个数的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>Math.min(a, b)</code>求2个数的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意只能求2个数</p><h2 id="复杂度">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>堆操作每次<span class="markdown-them-math-inline">$O(\log{(N)})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此总体是<span class="markdown-them-math-inline">$O(N\log{(N)})$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>数组<span class="markdown-them-math-inline">$O(N)$</span></li></ul><h2 id="代码">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minimumDifference</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">int</span> n = len / <span class="hljs-number">3</span>;        <span class="hljs-keyword">long</span>[] minv = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[n + <span class="hljs-number">1</span>];        minv[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(n, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a,Integer b)</span> </span>&#123;                <span class="hljs-keyword">return</span> b - a;            &#125;        &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            pq.offer(nums[i]);            minv[<span class="hljs-number">0</span>] += nums[i];        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt;= pq.peek()) &#123;                minv[i - n + <span class="hljs-number">1</span>] = minv[i - n];            &#125; <span class="hljs-keyword">else</span> &#123;                minv[i - n + <span class="hljs-number">1</span>] = minv[i - n] + nums[i] - pq.peek();                pq.poll();                pq.offer(nums[i]);            &#125;        &#125;        pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;(n);        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n; i &lt; len; i++) &#123;            pq.offer(nums[i]);            sum += nums[i];        &#125;        <span class="hljs-keyword">long</span> res = minv[n] - sum;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= n; i--) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; pq.peek())  &#123;                sum = sum + nums[i] - pq.peek();                pq.poll();                pq.offer(nums[i]);            &#125;            res = Math.min(res, minv[i - n] - sum);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><hr><h1 id="1233-删除子文件夹">1233. 删除子文件夹</h1><p>20250719<br><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/solutions/2097563/shan-chu-zi-wen-jian-jia-by-leetcode-sol-0x8d">官方题解</a><br>用时前排的代码</p><h2 id="解法1-排序">解法1 排序</h2><h3 id="思路-1">思路</h3><p>将字符串数组按字典序排序后一定会按照<span class="markdown-them-math-inline">$1$</span>个文件夹后面跟着<span class="markdown-them-math-inline">$n$</span>个(<span class="markdown-them-math-inline">$n \geq 0$</span>)该文件夹的子文件夹这种形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code>/a<span class="hljs-section">/a/b---</span>/c/d<span class="hljs-section">/c/d/e---</span>/c/f</code></pre></div><h3 id="字典序">字典序</h3><p><span class="markdown-them-math-inline">$aa &lt; ab &lt; abc$</span></p><ul><li>第一个不同的字母小的字典序小</li><li>如果一个字符串是另一个字符串的前缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且较短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的字典序较小</li><li><span class="markdown-them-math-inline">$/ &lt; 数字 &lt; 大写字母 &lt; 小写字母$</span> <code>ascii</code>码顺序</li></ul><h3 id="复杂度-1">复杂度</h3><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$l$</span>为字符串平均长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>排序<span class="markdown-them-math-inline">$O(N \log(N))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体<span class="markdown-them-math-inline">$O(Nl \log(N))$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存储结果<span class="markdown-them-math-inline">$O(Nl)$</span></li></ul><h3 id="其他-1">其他</h3><ul><li>字符串长度<code>s.length()</code></li><li>字符串子串<code>s.substring(a, b)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从a到b<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>包括a不包括b</li><li>数组排序<code>Arrays.sort(array)</code></li></ul><h3 id="优化">优化</h3><p>按照字符串长度排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时一个字符串的子串必然出现在它之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>用集合存储结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前字符串的前缀在集合内则舍弃当前字符串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则将此字符串加入集合</p><p>自定义数组排序Comparator</p><div class="highlight"><pre class="code"><code>Arrays.sort(folder, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;                <span class="hljs-keyword">return</span> s1.length() - s2.length();            &#125;        &#125;);</code></pre></div><h3 id="代码-1">代码</h3><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> </span>&#123;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        Arrays.sort(folder);        String pref = <span class="hljs-string">&quot;*&quot;</span>;        <span class="hljs-keyword">for</span> (String s : folder) &#123;            <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;/&quot;</span>) || s.contains(<span class="hljs-string">&quot;//&quot;</span>)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (!(s.length() &gt; pref.length() &amp;&amp; pref.equals(s.substring(<span class="hljs-number">0</span>, pref.length())) &amp;&amp; s.charAt(pref.length()) == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;                pref = s;                res.add(s);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><p>优化后</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> </span>&#123;        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(folder, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;                <span class="hljs-keyword">return</span> s1.length() - s2.length();            &#125;        &#125;);        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (String f : folder) &#123;            <span class="hljs-keyword">int</span> n = f.length();            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;                <span class="hljs-keyword">if</span> (f.charAt(i) == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;                    String sub = f.substring(<span class="hljs-number">0</span>, i);                    <span class="hljs-keyword">if</span> (set.contains(sub)) &#123;                        flag = <span class="hljs-keyword">true</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (!flag) &#123;                ans.add(f);                set.add(f);            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><h2 id="解法2-前缀树">解法2 前缀树</h2><h3 id="思路-2">思路</h3><p>按照<code>/</code>分割每一个文件夹构造前缀树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在最后一个节点处放置标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果遇到标记则返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将当前文件夹加入结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h3 id="复杂度-2">复杂度</h3><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>构造前缀树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>DFS需要<span class="markdown-them-math-inline">$O(Nl)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存储前缀树需要<span class="markdown-them-math-inline">$O(Nl)$</span></li></ul><h3 id="优化-1">优化</h3><ul><li>前缀树的节点可以存储字符串的哈希以提升效率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据范围规定文件夹只有小写字母<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将字符串当作数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择一个26及以上的数字当作进制数构造哈希<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虽然感觉碰撞率很高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以通过本题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>使用<code>str.hashCode()</code>时间上会慢一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li><li>在构造前缀树的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前节点存在且有标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则表示当前文件夹必然是子文件夹<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接舍弃当前文件夹<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li></ul><h3 id="其他-2">其他</h3><p>Map操作</p><ul><li><code>map.putIfAbsent(key, value)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果key不存在则执行<code>map.put(key, value)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果key存在则不执行</li></ul><h3 id="代码-2">代码</h3><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        <span class="hljs-keyword">int</span> index;        Map&lt;Integer, Trie&gt; children;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            index = -<span class="hljs-number">1</span>;            children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> </span>&#123;        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Trie root = <span class="hljs-keyword">new</span> Trie();        Trie cur = root;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; folder.length; i++) &#123;            <span class="hljs-keyword">int</span> hash = <span class="hljs-number">0</span>;            cur = root;            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; folder[i].length(); j++) &#123;                <span class="hljs-keyword">if</span> (folder[i].charAt(j) == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;                    <span class="hljs-keyword">if</span> (cur.index != -<span class="hljs-number">1</span>) &#123;                        flag = <span class="hljs-keyword">true</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    cur.children.putIfAbsent(hash, <span class="hljs-keyword">new</span> Trie());                    cur = cur.children.get(hash);                    hash = <span class="hljs-number">0</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    hash = hash * <span class="hljs-number">28</span> + folder[i].charAt(j);                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            cur.children.putIfAbsent(hash, <span class="hljs-keyword">new</span> Trie());            cur = cur.children.get(hash);            <span class="hljs-keyword">if</span> (cur.index == -<span class="hljs-number">1</span>) &#123;                cur.index = i;            &#125;                    &#125;        dfs(root, res, folder);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie cur, List&lt;String&gt; res, String[] folder)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur.index != -<span class="hljs-number">1</span>) &#123;            res.add(folder[cur.index]);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (Trie t : cur.children.values()) &#123;            dfs(t, res, folder);        &#125;    &#125;&#125;</code></pre></div><hr><h1 id="1948-删除系统中的重复文件夹">1948. 删除系统中的重复文件夹</h1><p>20250720<br><a href="https://leetcode.cn/problems/delete-duplicate-folders-in-system/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/delete-duplicate-folders-in-system/solutions/895642/shan-chu-xi-tong-zhong-de-zhong-fu-wen-j-ic32">官方题解</a><br>执行用时前排代码</p><h2 id="思路-3">思路</h2><p>后序遍历整棵树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生成每个节点的序列化子树,如果当前节点的序列化子树在集合中不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将它加入<code>map</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设置出现次数为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则次数加<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>然后DFS整棵树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前节点的序列化子树出现次数大于<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则不将它加入答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果等于<span class="markdown-them-math-inline">$1$</span>则将它加入答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><p>子树序列化方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br><span class="markdown-them-math-inline">$serial(node) = child1(serial(child1))child2(serial(child2))...childn(serial(childn))$</span></p><p><span class="markdown-them-math-inline">$child$</span>之间按照字典序排序</p><h2 id="优化1">优化1</h2><p>生成序列化子树时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不使用出现次数来判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给前缀树节点增加一个删除标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果在<code>Map</code>中查询到有节点存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则删除<code>Map</code>中的节点和当前节点</p><p>在DFS时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过删除标记判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果为真则返回</p><h2 id="优化2">优化2</h2><p>本题的输入保证了如果有<span class="markdown-them-math-inline">$n$</span>个路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则一定有<span class="markdown-them-math-inline">$n$</span>个前缀树节点</p><p>如果按照长度对路径数组排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果是按照第<span class="markdown-them-math-inline">$1$</span>层节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>第<span class="markdown-them-math-inline">$2$</span>层节点…直到最后一层节点分布的</p><p>从前向后遍历路径数组建树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次都会新增一个节点</p><p>从后向前遍历增加的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳过所有叶节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生成它的序列化子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在<code>Map</code>中查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将它加入<code>Map</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将查询到的节点设置删除标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将当前节点设置删除标记</p><p>对于子节点可以使用<code>TreeMap</code>存储以保证其按字典序排列</p><p>设置删除标记的时候要将它的子节点同时设置删除标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(如果有<span class="markdown-them-math-inline">$2$</span>个<span class="markdown-them-math-inline">$3$</span>层的树同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么必定存在<span class="markdown-them-math-inline">$2$</span>个<span class="markdown-them-math-inline">$2$</span>层的树同构(即<span class="markdown-them-math-inline">$3$</span>层树的子树)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除<span class="markdown-them-math-inline">$3$</span>层同构树前一定删除过它的所有<span class="markdown-them-math-inline">$2$</span>层子同构树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>)</p><p>最后从前向后遍历所有节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果该节点没被删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以将路径数组对应下标直接加入答案中</p><h2 id="代码-3">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; deleteDuplicateFolder(List&lt;List&lt;String&gt;&gt; paths) &#123;        Trie root = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span> (List&lt;String&gt; list : paths) &#123;            Trie cur = root;            <span class="hljs-keyword">for</span> (String s : list) &#123;                cur.children.putIfAbsent(s, <span class="hljs-keyword">new</span> Trie());                cur = cur.children.get(s);            &#125;        &#125;        Map&lt;String, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        getSerial(root, freq);        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        dfs(root, freq, res, path);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        String serial;        Map&lt;String, Trie&gt; children;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSerial</span><span class="hljs-params">(Trie cur, Map&lt;String, Integer&gt; freq)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur.children.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        List&lt;String&gt; cl = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;            String s = entry.getKey();            Trie t = entry.getValue();            getSerial(t, freq);            cl.add(s + <span class="hljs-string">&quot;(&quot;</span> + t.serial + <span class="hljs-string">&quot;)&quot;</span>);        &#125;        Collections.sort(cl);        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (String s : cl) &#123;            sb.append(s);        &#125;        cur.serial = sb.toString();        freq.put(cur.serial, freq.getOrDefault(cur.serial, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie cur, Map&lt;String, Integer&gt; freq, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path)</span> </span>&#123;        <span class="hljs-keyword">if</span> (freq.getOrDefault(cur.serial, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (!path.isEmpty()) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        &#125;        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;            String s = entry.getKey();            Trie t = entry.getValue();            path.add(s);            dfs(t, freq, res, path);            path.removeLast();        &#125;    &#125;&#125;</code></pre></div><p>优化1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; deleteDuplicateFolder(List&lt;List&lt;String&gt;&gt; paths) &#123;        Trie root = <span class="hljs-keyword">new</span> Trie();        <span class="hljs-keyword">for</span> (List&lt;String&gt; list : paths) &#123;            Trie cur = root;            <span class="hljs-keyword">for</span> (String s : list) &#123;                cur.children.putIfAbsent(s, <span class="hljs-keyword">new</span> Trie());                cur = cur.children.get(s);            &#125;        &#125;        Map&lt;String, Trie&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        getSerial(root, map);        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        dfs(root, res, path);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        String serial;        Map&lt;String, Trie&gt; children;        <span class="hljs-keyword">boolean</span> deleted;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            deleted = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setD</span><span class="hljs-params">()</span> </span>&#123;            deleted = <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSerial</span><span class="hljs-params">(Trie cur, Map&lt;String, Trie&gt; map)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur.children.isEmpty()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        List&lt;String&gt; cl = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;            String s = entry.getKey();            Trie t = entry.getValue();            getSerial(t, map);            cl.add(s + <span class="hljs-string">&quot;(&quot;</span> + t.serial + <span class="hljs-string">&quot;)&quot;</span>);        &#125;        Collections.sort(cl);        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (String s : cl) &#123;            sb.append(s);        &#125;        cur.serial = sb.toString();        Trie t = map.get(cur.serial);        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;            map.put(cur.serial, cur);        &#125; <span class="hljs-keyword">else</span> &#123;            t.setD();            cur.setD();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie cur, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur.deleted) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (!path.isEmpty()) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));        &#125;        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;            String s = entry.getKey();            Trie t = entry.getValue();            path.add(s);            dfs(t, res, path);            path.removeLast();        &#125;    &#125;&#125;</code></pre></div><p>优化2</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; deleteDuplicateFolder(List&lt;List&lt;String&gt;&gt; paths) &#123;        Trie root = <span class="hljs-keyword">new</span> Trie();        paths.sort(<span class="hljs-keyword">new</span> Comparator&lt;List&lt;String&gt;&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(List&lt;String&gt; l1, List&lt;String&gt; l2)</span> </span>&#123;                <span class="hljs-keyword">return</span> l1.size() - l2.size();            &#125;        &#125;);        <span class="hljs-keyword">int</span> n = paths.size();        List&lt;Trie&gt; tlist = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);        <span class="hljs-keyword">for</span> (List&lt;String&gt; list : paths) &#123;            Trie cur = root;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; list.size() - <span class="hljs-number">1</span>; i++) &#123;                String s = list.get(i);                cur = cur.children.get(s);            &#125;            Trie t = <span class="hljs-keyword">new</span> Trie();            cur.children.put(list.getLast(), t);            tlist.add(t);        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        Map&lt;String, Trie&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            Trie cur = tlist.get(i);            <span class="hljs-keyword">if</span> (cur.children.isEmpty()) &#123;                <span class="hljs-keyword">continue</span>;            &#125;                        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;                sb.append(entry.getKey()).append(<span class="hljs-string">&quot;(&quot;</span>).append(entry.getValue().serial).append(<span class="hljs-string">&quot;)&quot;</span>);            &#125;            cur.serial = sb.toString();            Trie t = map.get(cur.serial);            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;                map.put(cur.serial, cur);            &#125; <span class="hljs-keyword">else</span> &#123;                t.setD();                cur.setD();            &#125;            sb.setLength(<span class="hljs-number">0</span>);        &#125;        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (!tlist.get(i).deleted) &#123;                res.add(paths.get(i));            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;        String serial;        Map&lt;String, Trie&gt; children;        <span class="hljs-keyword">boolean</span> deleted;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;            children = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();            deleted = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setD</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (deleted) &#123;                <span class="hljs-keyword">return</span>;            &#125;            deleted = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (Trie t : children.values()) &#123;                t.setD();            &#125;        &#125;    &#125;&#125;</code></pre></div><hr><h1 id="1957-删除字符使字符串变好">1957. 删除字符使字符串变好</h1><p>20250721<br><a href="https://leetcode.cn/problems/delete-characters-to-make-fancy-string/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>执行用时前排代码</p><h2 id="思路-4">思路</h2><p>字符串长度小于3时直接返回</p><p>用一个指针存新字符串的结束位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历字符串至倒数第3个字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前字符与后面2个字符不相同则将该位置的字符加入新字符串中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针后移一位</p><p>默认将最后两个字符加入新字符串</p><p>实现上可以在同一个数组中操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为从前向后遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>向后判断字符是否相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针在遍历位置之前不会影响判断</p><h2 id="优化-2">优化</h2><p>使用<code>byte</code>数组存字符</p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">byte</span>[] sc = s.getBytes(java.nio.charset.StandartCharsets.ISO_8859_1);</code></pre></div><p>最后用<code>byte</code>数组构建<code>String</code></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">new</span> String(sc, <span class="hljs-number">0</span>, p, java.nio.charset.StandardCharsets.ISO_8859_1)</code></pre></div><h2 id="代码-4">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">makeFancyString</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">return</span> s;        &#125;        <span class="hljs-keyword">byte</span>[] sc = s.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1);        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">if</span> (!(sc[i] == sc[i + <span class="hljs-number">1</span>] &amp;&amp; sc[i] == sc[i + <span class="hljs-number">2</span>])) &#123;                sc[p++] = sc[i];            &#125;        &#125;        sc[p++] = sc[s.length() - <span class="hljs-number">2</span>];        sc[p++] = sc[s.length() - <span class="hljs-number">1</span>];        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(sc, <span class="hljs-number">0</span>, p, java.nio.charset.StandardCharsets.ISO_8859_1);    &#125;&#125;</code></pre></div><hr><h1 id="1695-删除子数组的最大得分">1695. 删除子数组的最大得分</h1><p>20250722<br><a href="https://leetcode.cn/problems/maximum-erasure-value/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/maximum-erasure-value/solutions/3719982/shan-chu-zi-shu-zu-de-zui-da-de-fen-by-l-jp9y">官方题解</a></p><p>执行用时前排代码</p><h2 id="思路-5">思路</h2><p>遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果这个数没出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将它加入集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用一个指针遍历到上一次出现这个数的下标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时更新集合(删除元素)和得分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>结果取得分的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p><h2 id="复杂度-3">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组时更新<code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且次数不会超过<span class="markdown-them-math-inline">$N$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总体为<span class="markdown-them-math-inline">$O(N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>需要一个<code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为<span class="markdown-them-math-inline">$O(N)$</span></li></ul><h2 id="优化-3">优化</h2><p>题目数据范围<span class="markdown-them-math-inline">$1 \leq nums[i] \leq 10^{4}$</span><br>初始化一个<span class="markdown-them-math-inline">$10^4 + 1$</span>大小的数组<span class="markdown-them-math-inline">$pren$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下标<span class="markdown-them-math-inline">$n$</span>的值表示上一次出现<span class="markdown-them-math-inline">$n$</span>值的前缀和</p><p>遍历数组时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用<span class="markdown-them-math-inline">$starts$</span>表示区间前一个下标的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么当前得分可以表示为<span class="markdown-them-math-inline">$ends - starts$</span></p><p>查询<span class="markdown-them-math-inline">$pren[nums[i]]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果大于<span class="markdown-them-math-inline">$starts$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示<span class="markdown-them-math-inline">$nums[i]$</span>在当前区间起点后出现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前得分为<span class="markdown-them-math-inline">$sum - pren[nums[i]]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新<span class="markdown-them-math-inline">$starts$</span>为<span class="markdown-them-math-inline">$pren[nums[i]]$</span></p><p>如果小于等于<span class="markdown-them-math-inline">$starts$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示这个数在当前区间起点之前出现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前得分为<span class="markdown-them-math-inline">$ends - starts$</span></p><h2 id="代码-5">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Set&lt;Integer&gt; s = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> tem = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            tem += nums[i];            <span class="hljs-keyword">while</span> (s.contains(nums[i])) &#123;                s.remove(nums[j]);                tem -= nums[j];                j++;            &#125;            s.add(nums[i]);            ans = Math.max(ans, tem);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><p>优化后</p><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] pren = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10001</span>];        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> ends = <span class="hljs-number">0</span>, starts = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span>(pren[num] &gt; starts) &#123;                starts = pren[num];            &#125;            ends += num;            pren[num] = ends;            ans = Math.max(ans, ends - starts);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="1717-删除子字符串的最大得分">1717. 删除子字符串的最大得分</h1><p>20250723<br><a href="https://leetcode.cn/problems/maximum-score-from-removing-substrings/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/maximum-score-from-removing-substrings/solutions/3731266/shan-chu-zi-zi-fu-chuan-de-zui-da-de-fen-0x3m">官方题解</a></p><h2 id="思路-6">思路</h2><p>假设<span class="markdown-them-math-inline">$ab$</span>得分大于<span class="markdown-them-math-inline">$ba$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于每个只包含<span class="markdown-them-math-inline">$a$</span>和<span class="markdown-them-math-inline">$b$</span>的最长子串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从前向后遍历贪心更多的<span class="markdown-them-math-inline">$ab$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历结束后加上剩余的<span class="markdown-them-math-inline">$ba$</span></p><p>实现时用<span class="markdown-them-math-inline">$cl$</span>存储得分高的字符串的第一个字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用<span class="markdown-them-math-inline">$cr$</span>存储得分高的字符串的第二个字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且使<span class="markdown-them-math-inline">$x$</span>为高分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$y$</span>为低分</p><p>假设<span class="markdown-them-math-inline">$ab$</span>得分更高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历字符串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设当前字符为<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$a$</span>的数量大于<span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$a$</span>的数量减<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得分加<span class="markdown-them-math-inline">$x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$a$</span>的数量为<span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$b$</span>的数量加<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>字符为<span class="markdown-them-math-inline">$a$</span>的时候<span class="markdown-them-math-inline">$a$</span>的数量加<span class="markdown-them-math-inline">$1$</span></p><p>遍历到非<span class="markdown-them-math-inline">$a$</span>或<span class="markdown-them-math-inline">$b$</span>的字符时该字串结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该子串必定只剩下<span class="markdown-them-math-inline">$b...ba...a(b \geq 0, a \geq 0)$</span>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得分加上<span class="markdown-them-math-inline">$min(cnta, cntb) \times y$</span></p><h2 id="复杂度-4">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不需要额外空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(1)$</span></li></ul><h2 id="其他-3">其他</h2><p>遍历字符串的字符<br><code>for (char c : s.toCharArray())</code></p><h2 id="代码-6">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumGain</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cntl = <span class="hljs-number">0</span>, cntr= <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> cl = x &gt; y ? <span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-string">&#x27;b&#x27;</span>;        <span class="hljs-keyword">char</span> cr = x &gt; y ? <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">int</span> t1 = Math.max(x, y);        <span class="hljs-keyword">int</span> t2 = Math.min(x, y);        x = t1;        y = t2;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> (c == cl) &#123;                cntl++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == cr) &#123;                <span class="hljs-keyword">if</span> (cntl == <span class="hljs-number">0</span>) &#123;                    cntr++;                &#125; <span class="hljs-keyword">else</span> &#123;                    ans += x;                    cntl--;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                ans += Math.min(cntl, cntr) * y;                cntl = <span class="hljs-number">0</span>;                cntr = <span class="hljs-number">0</span>;            &#125;        &#125;        ans += Math.min(cntl, cntr) * y;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><hr><h1 id="2322-从树中删除边的最小分数">2322. 从树中删除边的最小分数</h1><p>20250724<br><a href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/description/">题目链接</a></p><p>参考<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/solutions/3726042/cong-shu-zhong-shan-chu-bian-de-zui-xiao-mrrc">官方题解</a></p><h2 id="思路-7">思路</h2><p>前置知识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><ul><li>异或性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$a \oplus b = c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$b \oplus c = a$</span></li><li>DFS时间戳<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>DFS遍历初始化<code>in</code>和<code>out</code>数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果<code>i</code>是<code>j</code>的子节点则<span class="markdown-them-math-inline">$in[i] &gt; in[j]$</span>并且<span class="markdown-them-math-inline">$out[i] \leq out[j]$</span></li></ul><p>使用邻接表建(无向)图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设树以<span class="markdown-them-math-inline">$0$</span>为根,从<span class="markdown-them-math-inline">$0$</span>开始DFS整颗树并更新<code>in</code>和<code>out</code>数组,维护一个<code>xor</code>数组存储以<span class="markdown-them-math-inline">$i$</span>为根的子树的异或值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等于其本身的值与所有子树异或值的异或<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在DFS的同时可以完成</p><p>枚举除<span class="markdown-them-math-inline">$0$</span>以外的任意<span class="markdown-them-math-inline">$2$</span>个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除它们与它们父节点之间的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的<span class="markdown-them-math-inline">$3$</span>个连通块有<span class="markdown-them-math-inline">$3$</span>种情况</p><p>假设<span class="markdown-them-math-inline">$2$</span>个节点分别为<span class="markdown-them-math-inline">$i$</span>和<span class="markdown-them-math-inline">$j$</span></p><ul><li><span class="markdown-them-math-inline">$i$</span>是<span class="markdown-them-math-inline">$j$</span>的子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以<span class="markdown-them-math-inline">$i$</span>为根的连通块的异或值为<span class="markdown-them-math-inline">$xor[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$j$</span>为根的连通块要排除以<span class="markdown-them-math-inline">$i$</span>为根的连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>异或值为<span class="markdown-them-math-inline">$xor[j] \oplus xor[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$0$</span>为根的连通块的要排除整个以<span class="markdown-them-math-inline">$j$</span>为根的子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>异或值为<span class="markdown-them-math-inline">$xor[0] \oplus xor[j]$</span></li><li><span class="markdown-them-math-inline">$j$</span>是<span class="markdown-them-math-inline">$i$</span>的子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与上一种类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>三个连通块的异或值分别为<span class="markdown-them-math-inline">$xor[j]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$xor[i] \oplus xor[j]$</span>和<span class="markdown-them-math-inline">$xor[0] \oplus xor[i]$</span></li><li><span class="markdown-them-math-inline">$i$</span>和<span class="markdown-them-math-inline">$j$</span>互不为子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以<span class="markdown-them-math-inline">$i$</span>为根的连通块的异或值为<span class="markdown-them-math-inline">$xor[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$j$</span>为根的连通块的异或值为<span class="markdown-them-math-inline">$xor[j]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$0$</span>为根的连通块要排除以<span class="markdown-them-math-inline">$i$</span>为根的连通块和以<span class="markdown-them-math-inline">$j$</span>为根的连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>异或值为<span class="markdown-them-math-inline">$xor[0] \oplus xor[i] \oplus xor[j]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li></ul><h2 id="复杂度-5">复杂度</h2><ul><li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>枚举<span class="markdown-them-math-inline">$2$</span>个任意节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N ^ {2})$</span></li><li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>in</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>out</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>xor</code>等数组长度与节点数量相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li></ul><h2 id="其他-4">其他</h2><p>邻接表的定义及初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p><div class="highlight"><pre class="code"><code>List&lt;Integer&gt;[] g;g = <span class="hljs-keyword">new</span> List[n];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;    g[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();&#125;</code></pre></div><h2 id="代码-7">代码</h2><div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> in[];    <span class="hljs-keyword">int</span> out[];    <span class="hljs-keyword">int</span> s[];    List&lt;Integer&gt;[] g;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getres</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xo1, <span class="hljs-keyword">int</span> xo2, <span class="hljs-keyword">int</span> xo3)</span> </span>&#123;        <span class="hljs-keyword">return</span> Math.max(xo1, Math.max(xo2, xo3)) - Math.min(xo1, Math.min(xo2, xo3));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[][] edges)</span> </span>&#123;        g = <span class="hljs-keyword">new</span> List[nums.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            g[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        in = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        out = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.length; i++) &#123;            g[edges[i][<span class="hljs-number">0</span>]].add(edges[i][<span class="hljs-number">1</span>]);            g[edges[i][<span class="hljs-number">1</span>]].add(edges[i][<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            s[i] = nums[i];        &#125;        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;                <span class="hljs-keyword">if</span> (in[i] &gt; in[j] &amp;&amp; out[i] &lt;= out[j]) &#123;                    ans = Math.min(ans, getres(s[i], s[j] ^ s[i], s[<span class="hljs-number">0</span>] ^ s[j]));                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in[j] &gt; in[i] &amp;&amp; out[j] &lt;= out[i]) &#123;                    ans = Math.min(ans, getres(s[j], s[i] ^ s[j], s[<span class="hljs-number">0</span>] ^ s[i]));                &#125; <span class="hljs-keyword">else</span> &#123;                    ans = Math.min(ans, getres(s[i], s[j], s[<span class="hljs-number">0</span>] ^ s[i] ^ s[j]));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;        in[node] = clock++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[node].size(); i++) &#123;            <span class="hljs-keyword">if</span> (g[node].get(i) == fa) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            s[node] ^= dfs(g[node].get(i), node);        &#125;        out[node] = clock;        <span class="hljs-keyword">return</span> s[node];    &#125;&#125;</code></pre></div><hr><p>如有错误欢迎批评指正</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>comment test</title>
      <link href="/2025/06/11/comment-test/"/>
      <url>/2025/06/11/comment-test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>评论测试</p><span id="more"></span><p>hello</p><p>test some thing</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>password test</title>
      <link href="/2025/06/10/password-test/"/>
      <url>/2025/06/10/password-test/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="836f62555761a616a826f5931a6da5dd64abd8183d004554cabbe49f9d85e4c5">13295561a9b05d2864b59fc19a94899ea1464271088358fb708cc35f580c5d6b304ccc07fa77c67a3de3c176cfe357d76f17753f93cc7fd4e1823f1487bd2e1f963622fb19498452f4cf83b92d0d175e6007752bcc437c9addd6daf2a0de6e32b92ebd16e6693fd1e108484c493da04adabe4ac92d41d8b691ba11a6560740f38ee49b219e0dfb42614fe8f9c32cb50d4f06ac24088755e9f5b7e947aa4f5f24effe6137f55ae95dc8a6352c98fe69af9c537678013ccb91f170c6c84bd4978167c741021879dc2dfa03df85a6c6a65abe179834017314a74d96fc295f53f5fc5a3316f629e01c9a0958d9613fa8b13230abc43c42463bdaa9163622ce1d550b6d7e0ad071f392d230fbda3373cfd2e7d40c3493e566d833a92737c8c8a99095760ccd21b974b2cbc71bf1dbcf12aba94bcc5fb9e35d289ed9ba274785b9a0933c016d19d0939ad9eaa40456e049c6207178bbda0813495bd694ecabbc4e206d95e1222a16c089ff489848000463dbbbbbc8d0239eb5b7fbd1af91ee250f98e481310297ef3e6fb0e63879af0f9a03c32908c1dd5d47e5a689342ae20c44032179585c27cd882c612d890fd6502d8cd44a02beebe6437d07145d221da27476de896d2eabfa18da30a1284832241d449845307e0fcc8c74d1521a3aac3082ec16e3a77df3452746938316455a37907cef62d25ff951f7d635e72a682883c7917a5a5dca08435352328540ebb096d534ef223d79c1180574ce705805ee109979495ddc05bed7d04cc97289eaac3a234c5623918ed7bdd0ba9482501b34f386237dc714a6847416c5451189d822d1238ec8fa07e85404131822d2e153efb072b6e50081b1c9c3137eb13ac6f0d2fa367f186ef24be3788e4662f4249b643cff5ac1284a507925b43a6ebdfdb6ac1cd3aac130f7d9f9949c5173602d929de9d8dfae8ac8e3fc81f8b37fbda17fb8adb5f53af41dcdfecd2a271245bc62a5154423a84c708d3c3b36c2536095719e43833eeb63b688ad0b735fbe360fb437c46d15cab58ac7ae8babb1ac86e63e13e46130880326b7aa6170a97a6eccbc0c3a3d3c9c813c00d192a181bb73359e411cb7ed5902a54838bcc2765618c88eed42ac90d863812e1d1e5de136569391c5532739c3e0d9ef9832d06a3b4c37f9def67f692dfa0883b7028fb32d6967ca2a885e3904647a860701501c09e99e5f5619c9a6868a2b770a3c4eea1cb70ea43a3fa655177ebc66fff54a3afe3365898bfcbf5a0042a5f7707b39c8285142a6ffcf660e0e5586392d3db9b0a4ca17a2f227189aff855d30b6816f11af89ebf2fea66d7eb95fe2b76d9db8392d9a9a045735121e118bbb8a18cb9e7238ef6ec618e143012d6eb8b42a06c29faf4d6b5790dc105515f70f6cbd55966e9f8c2f9d0b11bd16d62a260f0820219c6ccce46c45e5ca73552a7e2058f18d8d9dea797746534d33c06d68ff05771b4d0fa4391182deacf6211a30fb7e9265ca50cea72c6a5a86cc8df8268e5ccb90615dd6a1cb226643887bd3b668c8e643a87a2932a1c2d22a8e659ad8f5b33a7b1c41ebad75a04b57cc51c4082ad5aba6f5bd7b99d6f0735af0593cb6342d5bfe4d4059261b9f0c9fbb07</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2025/06/08/test/"/>
      <url>/2025/06/08/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>摘要</p><span id="more"></span><h1 id="heading-level 1">Heading level 1</h1><h2 id="heading-level 2">Heading level 2</h2><h3 id="heading-level 3">Heading level 3</h3><h4 id="heading-level 4">Heading level 4</h4><p>This is the first line.</p><p>And this is the <strong>second</strong> line.</p><p><em>Italic</em> test</p><p><em><strong>really important</strong></em></p><blockquote><p>quote something</p><blockquote><p>nest</p></blockquote></blockquote><p>list</p><ul><li>first item<ul><li>indented item 1</li><li>indented item 2</li></ul></li><li>second item</li><li>third item</li><li>fourth item</li></ul><p>list2</p><ol><li>first item<br>something</li><li>second item</li><li>third item</li><li>fourth item</li></ol><p>some <code>code</code>.</p><p>reference test<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p><hr><p>line ^</p><p>github <a href="https://github.com">url</a></p><p>image test<br><img src="/2025/06/08/test/image1.jpg" alt="image"></p><p>reference test3<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)        cout &lt;&lt; i &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>reference test2<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>.</p><h1 id="heading-level 1 - 2">Heading level 1 - 2</h1><p>hello</p><div class="highlight"><pre class="code"><code><span class="hljs-built_in">print</span>(<span class="hljs-number">123</span>)</code></pre></div><ul><li><input type="checkbox" style="color: blue;" disabled>item1</li><li><input type="checkbox" style="color: blue;" disabled checked>item2</li><li><input type="checkbox" style="color: blue;" disabled>item3</li></ul><p>✅<br>❌</p><p><button id="ardmbtn">点我一下</button></p><script>  document.getElementById("ardmbtn").addEventListener("click", function() {    alert("按钮被按下了");  });</script><details><summary>More info</summary><blockquote><p>something</p></blockquote><p><strong>这里是 markdown</strong></p><ul><li>列表</li><li>列表</li></ul></details><pre class="mermaid">graph LR  A[Start] --> B{Error?};  B -->|Yes| C[Hmm...];  C --> D[Debug];  D --> B;  B ---->|No| E[Yay!];</pre><p>w</p><pre class="mermaid">flowchart TD    A[Start] --> B{Is it?}    B -- Yes --> C[OK]    C --> D[Rethink]    D --> B    B -- No ----> E[End]</pre><p>w</p><pre class="mermaid">flowchart LR  A e1@--> B  classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 900,animation: dash 25s linear infinite;  class e1 animate</pre><p>w</p><pre class="mermaid">pie title Pets adopted by volunteers    "Dogs" : 386    "Cats" : 85    "Rats" : 15</pre><p>w</p><div class="tag-common tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a data-target="first-unique-name-1">First unique name 1</a></li><li class="tab"><a data-target="first-unique-name-2">First unique name 2</a></li><li class="tab"><a data-target="first-unique-name-3">First unique name 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong><br><span class="hint--info hint--rounded hint--top" data-hint="hint something" ontouchstart>tag hint</span></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>This is Tab 2.</strong></p><style>.square {  width: 20px;  height: 20px;  background: orange;}</style><div class="square"></div><script type="module">import { animate } from 'https://esm.sh/animejs';animate('.square', { x: '17rem' , loop: true});</script></div><div class="tab-pane" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p><script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script><style>#mynetwork {  width: 600px;  height: 400px;  border: 1px solid lightgray;}</style><p>Create a simple network with some nodes and edges.</p><div id="mynetwork"></div><script>// create an array with nodesvar ph = true;var nodes = new vis.DataSet([  { id: 1, label: "Node 1", physics: ph },  { id: 2, label: "Node 2", physics: ph },  { id: 3, label: "Node 3", physics: ph },  { id: 4, label: "Node 4", physics: ph },  { id: 5, label: "Node 5", physics: ph },]);// create an array with edgesvar edges = new vis.DataSet([  { from: 1, to: 3 , label: '13', hoverWidth: 1.0, arrows: 'to, from', length: 100.0, smooth: {enabled: false}, physics: ph},  { from: 1, to: 2, length: 300.0, smooth: {enabled: false}, physics: ph},  { from: 2, to: 4, length: 100.0, smooth: {enabled: false}, physics: ph },  { from: 2, to: 5, length: 200.0, smooth: {enabled: false}, physics: ph},  { from: 3, to: 3 },  { from: 4, to: 1, length: 300.0, smooth: {enabled: false}, physics: ph },]);// create a networkvar container = document.getElementById("mynetwork");var data = {  nodes: nodes,  edges: edges,};var options = {};var network = new vis.Network(container, data, options);network.once("afterDrawing", function () {  network.fit({ animation: true });});</script><p><button id="changeph">change physics</button></p><script>  document.getElementById("changeph").addEventListener("click", function() {    ph = !ph;    edges.forEach(function (edge) {      network.clustering.updateEdge(edge.id, {physics: ph});      //console.log(edge.id + 'e changes');    });    nodes.forEach(function (node) {      network.clustering.updateClusteredNode(node.id, {physics: ph});      //console.log(node.id + 'n changes');    });  });</script></div></div></div><span class="hint--info hint--rounded hint--top" data-hint="hint something" ontouchstart>tag hint</span><h1 id="heading-level 1 - 3">Heading level 1 - 3</h1><h1 id="heading-level 1 - 4">Heading level 1 - 4</h1><h1 id="heading-level 1 - 5">Heading level 1 - 5</h1><h1 id="heading-level 1 - 6">Heading level 1 - 6</h1><h1 id="heading-level 1 - 7">Heading level 1 - 7</h1><h1 id="heading-level 1 - 8">Heading level 1 - 8</h1><h1 id="heading-level 1 - 9">Heading level 1 - 9</h1><h1 id="heading-level 1 - 10">Heading level 1 - 10</h1><h1 id="heading-level 1 - 11">Heading level 1 - 11</h1><h1 id="heading-level 1 - 12">Heading level 1 - 12</h1><h1 id="heading-level 1 - 13">Heading level 1 - 13</h1><h1 id="heading-level 1 - 14">Heading level 1 - 14</h1><h1 id="heading-level 1 - 15">Heading level 1 - 15</h1><h1 id="heading-level 1 - 16">Heading level 1 - 16</h1><h1 id="heading-level 1 - 17">Heading level 1 - 17</h1><h2 id="21">21</h2><h3 id="211">211</h3><h3 id="212">212</h3><h3 id="213">213</h3><h3 id="214">214</h3><h2 id="22">22</h2><h3 id="221">221</h3><h3 id="222">222</h3><h4 id="2221">2221</h4><h4 id="2222">2222</h4><h3 id="223">223</h3><h2 id="23">23</h2><h3 id="231">231</h3><h3 id="232">232</h3><h1 id="heading-level 1 - 18">Heading level 1 - 18</h1><h1 id="heading-level 1 - 19">Heading level 1 - 19</h1><h1 id="heading-level 1 - 20">Heading level 1 - 20</h1><h1 id="heading-level 1 - 21">Heading level 1 - 21</h1><h1 id="heading-level 1 - 22">Heading level 1 - 22</h1><h1 id="heading-level 1 - 23">Heading level 1 - 23</h1><h1 id="heading-level 1 - 24">Heading level 1 - 24</h1><h1 id="heading-level 1 - 25">Heading level 1 - 25</h1><h1 id="heading-level 1 - 26">Heading level 1 - 26</h1><h1 id="heading-level 1 - 27">Heading level 1 - 27</h1><h1 id="heading-level 1 - 28">Heading level 1 - 28</h1><h1 id="heading-level 1 - 29">Heading level 1 - 29</h1><h1 id="heading-level 1 - 30">Heading level 1 - 30</h1><h1 id="heading-level 1 - 31">Heading level 1 - 31</h1><h1 id="heading-level 1 - 32">Heading level 1 - 32</h1><h1 id="heading-level 1 - 33">Heading level 1 - 33</h1><h1 id="heading-level 1 - 34">Heading level 1 - 34</h1><h1 id="heading-level 1 - 35">Heading level 1 - 35</h1><h1 id="heading-level 1 - 36">Heading level 1 - 36</h1><h1 id="heading-level 1 - 37">Heading level 1 - 37</h1><h1 id="heading-level 1 - 38">Heading level 1 - 38</h1><h1 id="heading-level 1 - 39">Heading level 1 - 39</h1><h1 id="heading-level 1 - 40">Heading level 1 - 40</h1><h1 id="heading-level 1-1">Heading level 1</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com">https://github.com</a> and other decription <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://cn.bing.com">https://cn.bing.com</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
