<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Leetcode Daily 20250718-20250724 | Dave233</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <link
    rel="stylesheet"
    href="https://unpkg.com/@waline/client@v3/dist/waline.css"
  />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4Q6Gf2aSP4eDXB8Miphtr37CMZZQ5oXLH2yaXMJ2w8e2ZtHTl7GptT4jmndRuHDT" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js" integrity="sha384-j1CDi7MgGQ12Z7Qab0qlWQ/Qqz24Gc6BM0thvEMVjHnfYGF0rmFCozFSxQBxwHKO" crossorigin="anonymous"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="Leetcode 20250718到20250724每日一题的记录，使用Java解题">
  
  
    <link rel="alternate" href="/atom.xml" title="Dave233" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  

  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/newmenu">NewMenu</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
    <div class="main-nav-space-between"></div>

    <a id="nav-search-btn" class="nav-icon" data-bs-toggle="modal" data-bs-target="#searchModal" title="搜索"></a>

    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="/" id="logo">Dave233</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-Leetcode-Daily-20250718-20250724" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/24/leetcode-daily-20250718-20250724/" class="article-date">
  <time class="dt-published" datetime="2025-07-24T12:24:27.000Z" itemprop="datePublished">2025-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Leetcode Daily 20250718-20250724
    </h1>
  

      </header>
    
    
<div id="article-toc">
    <h2 class="widget-title">目录</h2>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2163-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%90%8E%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC"><span class="toc-number">1.</span> <span class="toc-text">2163. 删除元素后和的最小差值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%A4%A7%E9%A1%B6%E5%A0%86(%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)"><span class="toc-number">1.2.</span> <span class="toc-text">Java 大顶堆(优先队列)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">优先队列相关操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.4.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.</span> <span class="toc-text">1233. 删除子文件夹</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%B3%951-%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">解法1 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E5%BA%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">字典序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="toc-number">2.1.4.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.5.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.1.6.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%B3%952-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">2.2.</span> <span class="toc-text">解法2 前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-2"><span class="toc-number">2.2.4.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.2.5.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1948-%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">3.</span> <span class="toc-text">1948. 删除系统中的重复文件夹</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%961"><span class="toc-number">3.2.</span> <span class="toc-text">优化1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%962"><span class="toc-number">3.3.</span> <span class="toc-text">优化2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">3.4.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1957-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E5%A5%BD"><span class="toc-number">4.</span> <span class="toc-text">1957. 删除字符使字符串变好</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-2"><span class="toc-number">4.2.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">4.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">5.</span> <span class="toc-text">1695. 删除子数组的最大得分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">5.2.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-3"><span class="toc-number">5.3.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">5.4.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1717-%E5%88%A0%E9%99%A4%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">6.</span> <span class="toc-text">1717. 删除子字符串的最大得分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">6.2.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-3"><span class="toc-number">6.3.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">6.4.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2322-%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%BE%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%86%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">2322. 从树中删除边的最小分数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-number">7.2.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-4"><span class="toc-number">7.3.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">7.4.</span> <span class="toc-text">代码</span></a></li></ol></li></ol>
</div>

    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Leetcode 20250718到20250724每日一题的记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用Java解题</p>
<span id="more"></span>
<h1 id="2163-删除元素后和的最小差值">2163. 删除元素后和的最小差值</h1>
<p>20250718<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/description/">题目链接</a></p>
<h2 id="思路">思路</h2>
<p>为了使前<span class="markdown-them-math-inline">$n$</span>个数减后<span class="markdown-them-math-inline">$n$</span>个数的差值最小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>要使前<span class="markdown-them-math-inline">$n$</span>个数尽可能小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后<span class="markdown-them-math-inline">$n$</span>个数尽可能大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在前<span class="markdown-them-math-inline">$n + i$</span>个数中去掉<span class="markdown-them-math-inline">$i$</span>个最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>后<span class="markdown-them-math-inline">$2n - i$</span>个数中去掉<span class="markdown-them-math-inline">$n - i$</span>个最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(<span class="markdown-them-math-inline">$0 \leq i \leq n$</span>)</p>
<p>维护一个数组代表当前<span class="markdown-them-math-inline">$i$</span>下前面数组和的最小值</p>
<p>用大顶堆将前<span class="markdown-them-math-inline">$n$</span>个元素入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>向后遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于之后的每一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果小于当前最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将最大值出堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将这个数入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新当前和的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果大于当前最大值则不用操作,和的最小值不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>用小顶堆将后<span class="markdown-them-math-inline">$n$</span>个元素入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>向前遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于之后的每一个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果大于当前最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将最小值出堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再将这个数入堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新当前和的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果小于当前最小值则不用操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>和的最大值不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>实现时这里可以开始更新结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>取上面对应下标的最小值数组与当前和的最大值的差的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>不用再用一个数组存最大值了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<h2 id="java-大顶堆(优先队列)">Java 大顶堆(优先队列)</h2>
<div class="highlight"><pre class="code"><code>PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(n, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a,Integer b)</span> </span>&#123;
                <span class="hljs-keyword">return</span> b - a;
            &#125;
        &#125;); <span class="hljs-comment">//优先队列</span>
</code></pre></div>
<h2 id="优先队列相关操作">优先队列相关操作</h2>
<ul>
<li><code>pq.offer(i)</code>元素入堆
<ul>
<li>与<code>pq.add(i)</code>的区别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>向满的队列加元素时<code>pq.offer(i)</code>会返回<code>false</code>,<code>pq.add(i)</code>会抛出异常</li>
</ul>
</li>
<li><code>pq.poll()</code>元素出堆并返回当前最大<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>值
<ul>
<li>与<code>pq.remove()</code>的区别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>向空的队列删元素时<code>pq.poll()</code>会返回<code>null</code>,<code>pq.remove()</code>会抛出异常</li>
</ul>
</li>
<li><code>pq.peek()</code>返回当前最大<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>值
<ul>
<li>与<code>pq.element()</code>的区别是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>向空的队列删元素时<code>pq.peek()</code>会返回<code>null</code>,<code>pq.element()</code>会抛出异常</li>
</ul>
</li>
</ul>
<h2 id="其他">其他</h2>
<p><code>Math.max(a, b)</code>求2个数的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>Math.min(a, b)</code>求2个数的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意只能求2个数</p>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>堆操作每次<span class="markdown-them-math-inline">$O(\log{(N)})$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此总体是<span class="markdown-them-math-inline">$O(N\log{(N)})$</span></li>
<li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>数组<span class="markdown-them-math-inline">$O(N)$</span></li>
</ul>
<h2 id="代码">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">minimumDifference</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = nums.length;
        <span class="hljs-keyword">int</span> n = len / <span class="hljs-number">3</span>;
        <span class="hljs-keyword">long</span>[] minv = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[n + <span class="hljs-number">1</span>];
        minv[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(n, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a,Integer b)</span> </span>&#123;
                <span class="hljs-keyword">return</span> b - a;
            &#125;
        &#125;);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            pq.offer(nums[i]);
            minv[<span class="hljs-number">0</span>] += nums[i];
        &#125;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;
            <span class="hljs-keyword">if</span> (nums[i] &gt;= pq.peek()) &#123;
                minv[i - n + <span class="hljs-number">1</span>] = minv[i - n];
            &#125; <span class="hljs-keyword">else</span> &#123;
                minv[i - n + <span class="hljs-number">1</span>] = minv[i - n] + nums[i] - pq.peek();
                pq.poll();
                pq.offer(nums[i]);
            &#125;
        &#125;
        pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;(n);
        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n; i &lt; len; i++) &#123;
            pq.offer(nums[i]);
            sum += nums[i];
        &#125;
        <span class="hljs-keyword">long</span> res = minv[n] - sum;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= n; i--) &#123;
            <span class="hljs-keyword">if</span> (nums[i] &gt; pq.peek())  &#123;
                sum = sum + nums[i] - pq.peek();
                pq.poll();
                pq.offer(nums[i]);
            &#125;
            res = Math.min(res, minv[i - n] - sum);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="1233-删除子文件夹">1233. 删除子文件夹</h1>
<p>20250719<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/description/">题目链接</a></p>
<h2 id="解法1-排序">解法1 排序</h2>
<h3 id="思路-1">思路</h3>
<p>将字符串数组按字典序排序后一定会按照<span class="markdown-them-math-inline">$1$</span>个文件夹后面跟着<span class="markdown-them-math-inline">$n$</span>个(<span class="markdown-them-math-inline">$n \geq 0$</span>)该文件夹的子文件夹这种形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><br>
例如<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="highlight"><pre class="code"><code>/a
<span class="hljs-section">/a/b
---</span>
/c/d
<span class="hljs-section">/c/d/e
---</span>
/c/f
</code></pre></div>
<h3 id="字典序">字典序</h3>
<p><span class="markdown-them-math-inline">$aa &lt; ab &lt; abc$</span></p>
<ul>
<li>第一个不同的字母小的字典序小</li>
<li>如果一个字符串是另一个字符串的前缀<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且较短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它的字典序较小</li>
<li><span class="markdown-them-math-inline">$/ &lt; 数字 &lt; 大写字母 &lt; 小写字母$</span> <code>ascii</code>码顺序</li>
</ul>
<h3 id="复杂度-1">复杂度</h3>
<ul>
<li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><span class="markdown-them-math-inline">$l$</span>为字符串平均长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>排序<span class="markdown-them-math-inline">$O(N \log(N))$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体<span class="markdown-them-math-inline">$O(Nl \log(N))$</span></li>
<li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存储结果<span class="markdown-them-math-inline">$O(Nl)$</span></li>
</ul>
<h3 id="其他-1">其他</h3>
<ul>
<li>字符串长度<code>s.length()</code></li>
<li>字符串子串<code>s.substring(a, b)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从a到b<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>包括a不包括b</li>
<li>数组排序<code>Arrays.sort(array)</code></li>
</ul>
<h3 id="优化">优化</h3>
<p>按照字符串长度排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>此时一个字符串的子串必然出现在它之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>用集合存储结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前字符串的前缀在集合内则舍弃当前字符串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则将此字符串加入集合</p>
<p>自定义数组排序Comparator</p>
<div class="highlight"><pre class="code"><code>Arrays.sort(folder, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;
                <span class="hljs-keyword">return</span> s1.length() - s2.length();
            &#125;

        &#125;);
</code></pre></div>
<h3 id="代码-1">代码</h3>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> </span>&#123;
        List&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        Arrays.sort(folder);
        String pref = <span class="hljs-string">&quot;*&quot;</span>;
        <span class="hljs-keyword">for</span> (String s : folder) &#123;
            <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;/&quot;</span>) || s.contains(<span class="hljs-string">&quot;//&quot;</span>)) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">if</span> (!(s.length() &gt; pref.length() &amp;&amp; pref.equals(s.substring(<span class="hljs-number">0</span>, pref.length())) &amp;&amp; s.charAt(pref.length()) == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;
                pref = s;
                res.add(s);
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;
</code></pre></div>
<p>优化后</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> </span>&#123;
        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Arrays.sort(folder, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;
                <span class="hljs-keyword">return</span> s1.length() - s2.length();
            &#125;

        &#125;);
        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">for</span> (String f : folder) &#123;
            <span class="hljs-keyword">int</span> n = f.length();
            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
                <span class="hljs-keyword">if</span> (f.charAt(i) == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;
                    String sub = f.substring(<span class="hljs-number">0</span>, i);
                    <span class="hljs-keyword">if</span> (set.contains(sub)) &#123;
                        flag = <span class="hljs-keyword">true</span>;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (!flag) &#123;
                ans.add(f);
                set.add(f);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;
</code></pre></div>
<h2 id="解法2-前缀树">解法2 前缀树</h2>
<h3 id="思路-2">思路</h3>
<p>按照<code>/</code>分割每一个文件夹构造前缀树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在最后一个节点处放置标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>然后DFS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果遇到标记则返回<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并将当前文件夹加入结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="复杂度-2">复杂度</h3>
<ul>
<li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>构造前缀树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>DFS需要<span class="markdown-them-math-inline">$O(Nl)$</span></li>
<li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存储前缀树需要<span class="markdown-them-math-inline">$O(Nl)$</span></li>
</ul>
<h3 id="优化-1">优化</h3>
<ul>
<li>前缀树的节点可以存储字符串的哈希以提升效率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据范围规定文件夹只有小写字母<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将字符串当作数字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择一个26及以上的数字当作进制数构造哈希<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虽然感觉碰撞率很高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是可以通过本题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>使用<code>str.hashCode()</code>时间上会慢一些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>在构造前缀树的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前节点存在且有标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则表示当前文件夹必然是子文件夹<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以直接舍弃当前文件夹<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<h3 id="其他-2">其他</h3>
<p>Map操作</p>
<ul>
<li><code>map.putIfAbsent(key, value)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果key不存在则执行<code>map.put(key, value)</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果key存在则不执行</li>
</ul>
<h3 id="代码-2">代码</h3>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;
        <span class="hljs-keyword">int</span> index;
        Map&lt;Integer, Trie&gt; children;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;
            index = -<span class="hljs-number">1</span>;
            children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(String[] folder)</span> </span>&#123;
        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Trie root = <span class="hljs-keyword">new</span> Trie();
        Trie cur = root;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; folder.length; i++) &#123;
            <span class="hljs-keyword">int</span> hash = <span class="hljs-number">0</span>;
            cur = root;
            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
            
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; folder[i].length(); j++) &#123;
                <span class="hljs-keyword">if</span> (folder[i].charAt(j) == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;
                    <span class="hljs-keyword">if</span> (cur.index != -<span class="hljs-number">1</span>) &#123;
                        flag = <span class="hljs-keyword">true</span>;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                    cur.children.putIfAbsent(hash, <span class="hljs-keyword">new</span> Trie());
                    cur = cur.children.get(hash);
                    hash = <span class="hljs-number">0</span>;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    hash = hash * <span class="hljs-number">28</span> + folder[i].charAt(j);
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (flag) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            cur.children.putIfAbsent(hash, <span class="hljs-keyword">new</span> Trie());
            cur = cur.children.get(hash);
            <span class="hljs-keyword">if</span> (cur.index == -<span class="hljs-number">1</span>) &#123;
                cur.index = i;
            &#125;
            
        &#125;

        dfs(root, res, folder);
        <span class="hljs-keyword">return</span> res;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie cur, List&lt;String&gt; res, String[] folder)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (cur.index != -<span class="hljs-number">1</span>) &#123;
            res.add(folder[cur.index]);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (Trie t : cur.children.values()) &#123;
            dfs(t, res, folder);
        &#125;
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="1948-删除系统中的重复文件夹">1948. 删除系统中的重复文件夹</h1>
<p>20250720<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-duplicate-folders-in-system/description/">题目链接</a></p>
<h2 id="思路-3">思路</h2>
<p>后序遍历整棵树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生成每个节点的序列化子树,如果当前节点的序列化子树在集合中不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将它加入<code>map</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设置出现次数为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则次数加<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后DFS整棵树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前节点的序列化子树出现次数大于<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则不将它加入答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果等于<span class="markdown-them-math-inline">$1$</span>则将它加入答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>子树序列化方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><br>
<span class="markdown-them-math-inline">$serial(node) = child1(serial(child1))child2(serial(child2))...childn(serial(childn))$</span></p>
<p><span class="markdown-them-math-inline">$child$</span>之间按照字典序排序</p>
<h2 id="优化1">优化1</h2>
<p>生成序列化子树时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不使用出现次数来判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给前缀树节点增加一个删除标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果在<code>Map</code>中查询到有节点存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则删除<code>Map</code>中的节点和当前节点</p>
<p>在DFS时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过删除标记判断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果为真则返回</p>
<h2 id="优化2">优化2</h2>
<p>本题的输入保证了如果有<span class="markdown-them-math-inline">$n$</span>个路径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则一定有<span class="markdown-them-math-inline">$n$</span>个前缀树节点</p>
<p>如果按照长度对路径数组排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果是按照第<span class="markdown-them-math-inline">$1$</span>层节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>第<span class="markdown-them-math-inline">$2$</span>层节点…直到最后一层节点分布的</p>
<p>从前向后遍历路径数组建树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次都会新增一个节点</p>
<p>从后向前遍历增加的节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跳过所有叶节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生成它的序列化子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在<code>Map</code>中查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果不存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将它加入<code>Map</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将查询到的节点设置删除标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将当前节点设置删除标记</p>
<p>对于子节点可以使用<code>TreeMap</code>存储以保证其按字典序排列</p>
<p>设置删除标记的时候要将它的子节点同时设置删除标记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(如果有<span class="markdown-them-math-inline">$2$</span>个<span class="markdown-them-math-inline">$3$</span>层的树同构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么必定存在<span class="markdown-them-math-inline">$2$</span>个<span class="markdown-them-math-inline">$2$</span>层的树同构(即<span class="markdown-them-math-inline">$3$</span>层树的子树)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除<span class="markdown-them-math-inline">$3$</span>层同构树前一定删除过它的所有<span class="markdown-them-math-inline">$2$</span>层子同构树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>)</p>
<p>最后从前向后遍历所有节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果该节点没被删除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可以将路径数组对应下标直接加入答案中</p>
<h2 id="代码-3">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; deleteDuplicateFolder(List&lt;List&lt;String&gt;&gt; paths) &#123;
        Trie root = <span class="hljs-keyword">new</span> Trie();
        <span class="hljs-keyword">for</span> (List&lt;String&gt; list : paths) &#123;
            Trie cur = root;
            <span class="hljs-keyword">for</span> (String s : list) &#123;
                cur.children.putIfAbsent(s, <span class="hljs-keyword">new</span> Trie());
                cur = cur.children.get(s);
            &#125;
        &#125;
        Map&lt;String, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        getSerial(root, freq);

        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        dfs(root, freq, res, path);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;
        String serial;
        Map&lt;String, Trie&gt; children;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;
            children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSerial</span><span class="hljs-params">(Trie cur, Map&lt;String, Integer&gt; freq)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (cur.children.isEmpty()) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        List&lt;String&gt; cl = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;
            String s = entry.getKey();
            Trie t = entry.getValue();
            getSerial(t, freq);
            cl.add(s + <span class="hljs-string">&quot;(&quot;</span> + t.serial + <span class="hljs-string">&quot;)&quot;</span>);
        &#125;
        Collections.sort(cl);
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (String s : cl) &#123;
            sb.append(s);
        &#125;
        cur.serial = sb.toString();
        freq.put(cur.serial, freq.getOrDefault(cur.serial, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie cur, Map&lt;String, Integer&gt; freq, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (freq.getOrDefault(cur.serial, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (!path.isEmpty()) &#123;
            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));
        &#125;
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;
            String s = entry.getKey();
            Trie t = entry.getValue();
            path.add(s);
            dfs(t, freq, res, path);
            path.removeLast();
        &#125;
    &#125;
&#125;
</code></pre></div>
<p>优化1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; deleteDuplicateFolder(List&lt;List&lt;String&gt;&gt; paths) &#123;
        Trie root = <span class="hljs-keyword">new</span> Trie();
        <span class="hljs-keyword">for</span> (List&lt;String&gt; list : paths) &#123;
            Trie cur = root;
            <span class="hljs-keyword">for</span> (String s : list) &#123;
                cur.children.putIfAbsent(s, <span class="hljs-keyword">new</span> Trie());
                cur = cur.children.get(s);
            &#125;
        &#125;
        Map&lt;String, Trie&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        getSerial(root, map);

        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        dfs(root, res, path);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;
        String serial;
        Map&lt;String, Trie&gt; children;
        <span class="hljs-keyword">boolean</span> deleted;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;
            children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
            deleted = <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setD</span><span class="hljs-params">()</span> </span>&#123;
            deleted = <span class="hljs-keyword">true</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSerial</span><span class="hljs-params">(Trie cur, Map&lt;String, Trie&gt; map)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (cur.children.isEmpty()) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        List&lt;String&gt; cl = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;
            String s = entry.getKey();
            Trie t = entry.getValue();
            getSerial(t, map);
            cl.add(s + <span class="hljs-string">&quot;(&quot;</span> + t.serial + <span class="hljs-string">&quot;)&quot;</span>);
        &#125;
        Collections.sort(cl);
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (String s : cl) &#123;
            sb.append(s);
        &#125;
        cur.serial = sb.toString();
        Trie t = map.get(cur.serial);
        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;
            map.put(cur.serial, cur);
        &#125; <span class="hljs-keyword">else</span> &#123;
            t.setD();
            cur.setD();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie cur, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (cur.deleted) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (!path.isEmpty()) &#123;
            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));
        &#125;
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;
            String s = entry.getKey();
            Trie t = entry.getValue();
            path.add(s);
            dfs(t, res, path);
            path.removeLast();
        &#125;
    &#125;
&#125;
</code></pre></div>
<p>优化2</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; deleteDuplicateFolder(List&lt;List&lt;String&gt;&gt; paths) &#123;
        Trie root = <span class="hljs-keyword">new</span> Trie();
        paths.sort(<span class="hljs-keyword">new</span> Comparator&lt;List&lt;String&gt;&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(List&lt;String&gt; l1, List&lt;String&gt; l2)</span> </span>&#123;
                <span class="hljs-keyword">return</span> l1.size() - l2.size();
            &#125;
        &#125;);
        <span class="hljs-keyword">int</span> n = paths.size();
        List&lt;Trie&gt; tlist = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);
        <span class="hljs-keyword">for</span> (List&lt;String&gt; list : paths) &#123;
            Trie cur = root;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; list.size() - <span class="hljs-number">1</span>; i++) &#123;
                String s = list.get(i);
                cur = cur.children.get(s);
            &#125;
            Trie t = <span class="hljs-keyword">new</span> Trie();
            cur.children.put(list.getLast(), t);
            tlist.add(t);
        &#125;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        Map&lt;String, Trie&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            Trie cur = tlist.get(i);
            <span class="hljs-keyword">if</span> (cur.children.isEmpty()) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            
            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Trie&gt; entry : cur.children.entrySet()) &#123;
                sb.append(entry.getKey()).append(<span class="hljs-string">&quot;(&quot;</span>).append(entry.getValue().serial).append(<span class="hljs-string">&quot;)&quot;</span>);
            &#125;
            cur.serial = sb.toString();
            Trie t = map.get(cur.serial);
            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;
                map.put(cur.serial, cur);
            &#125; <span class="hljs-keyword">else</span> &#123;
                t.setD();
                cur.setD();
            &#125;
            sb.setLength(<span class="hljs-number">0</span>);
        &#125;
        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">if</span> (!tlist.get(i).deleted) &#123;
                res.add(paths.get(i));
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;
        String serial;
        Map&lt;String, Trie&gt; children;
        <span class="hljs-keyword">boolean</span> deleted;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;
            children = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();
            deleted = <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setD</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (deleted) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;
            deleted = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">for</span> (Trie t : children.values()) &#123;
                t.setD();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="1957-删除字符使字符串变好">1957. 删除字符使字符串变好</h1>
<p>20250721<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-characters-to-make-fancy-string/description/">题目链接</a></p>
<h2 id="思路-4">思路</h2>
<p>字符串长度小于3时直接返回</p>
<p>用一个指针存新字符串的结束位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历字符串至倒数第3个字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果当前字符与后面2个字符不相同则将该位置的字符加入新字符串中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针后移一位</p>
<p>默认将最后两个字符加入新字符串</p>
<p>实现上可以在同一个数组中操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为从前向后遍历<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>向后判断字符是否相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针在遍历位置之前不会影响判断</p>
<h2 id="优化-2">优化</h2>
<p>使用<code>byte</code>数组存字符</p>
<div class="highlight"><pre class="code"><code><span class="hljs-keyword">byte</span>[] sc = s.getBytes(java.nio.charset.StandartCharsets.ISO_8859_1);
</code></pre></div>
<p>最后用<code>byte</code>数组构建<code>String</code></p>
<div class="highlight"><pre class="code"><code><span class="hljs-keyword">new</span> String(sc, <span class="hljs-number">0</span>, p, java.nio.charset.StandardCharsets.ISO_8859_1)
</code></pre></div>
<h2 id="代码-4">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">makeFancyString</span><span class="hljs-params">(String s)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">3</span>) &#123;
            <span class="hljs-keyword">return</span> s;
        &#125;
        <span class="hljs-keyword">byte</span>[] sc = s.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1);
        <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">2</span>; i++) &#123;
            <span class="hljs-keyword">if</span> (!(sc[i] == sc[i + <span class="hljs-number">1</span>] &amp;&amp; sc[i] == sc[i + <span class="hljs-number">2</span>])) &#123;
                sc[p++] = sc[i];
            &#125;
        &#125;
        sc[p++] = sc[s.length() - <span class="hljs-number">2</span>];
        sc[p++] = sc[s.length() - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(sc, <span class="hljs-number">0</span>, p, java.nio.charset.StandardCharsets.ISO_8859_1);
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="1695-删除子数组的最大得分">1695. 删除子数组的最大得分</h1>
<p>20250722<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-erasure-value/description/">题目链接</a></p>
<h2 id="思路-5">思路</h2>
<p>遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果这个数没出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将它加入集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果出现过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用一个指针遍历到上一次出现这个数的下标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时更新集合(删除元素)和得分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>结果取得分的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="复杂度-3">复杂度</h2>
<ul>
<li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组时更新<code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且次数不会超过<span class="markdown-them-math-inline">$N$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>总体为<span class="markdown-them-math-inline">$O(N)$</span></li>
<li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>需要一个<code>HashSet</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为<span class="markdown-them-math-inline">$O(N)$</span></li>
</ul>
<h2 id="优化-3">优化</h2>
<p>题目数据范围<span class="markdown-them-math-inline">$1 \leq nums[i] \leq 10^{4}$</span><br>
初始化一个<span class="markdown-them-math-inline">$10^4 + 1$</span>大小的数组<span class="markdown-them-math-inline">$pren$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>下标<span class="markdown-them-math-inline">$n$</span>的值表示上一次出现<span class="markdown-them-math-inline">$n$</span>值的前缀和</p>
<p>遍历数组时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用<span class="markdown-them-math-inline">$starts$</span>表示区间前一个下标的前缀和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么当前得分可以表示为<span class="markdown-them-math-inline">$ends - starts$</span></p>
<p>查询<span class="markdown-them-math-inline">$pren[nums[i]]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果大于<span class="markdown-them-math-inline">$starts$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示<span class="markdown-them-math-inline">$nums[i]$</span>在当前区间起点后出现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前得分为<span class="markdown-them-math-inline">$sum - pren[nums[i]]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>更新<span class="markdown-them-math-inline">$starts$</span>为<span class="markdown-them-math-inline">$pren[nums[i]]$</span></p>
<p>如果小于等于<span class="markdown-them-math-inline">$starts$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示这个数在当前区间起点之前出现了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前得分为<span class="markdown-them-math-inline">$ends - starts$</span></p>
<h2 id="代码-5">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        Set&lt;Integer&gt; s = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> tem = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            tem += nums[i];
            <span class="hljs-keyword">while</span> (s.contains(nums[i])) &#123;
                s.remove(nums[j]);
                tem -= nums[j];
                j++;
            &#125;
            s.add(nums[i]);
            ans = Math.max(ans, tem);
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;
</code></pre></div>
<p>优化后</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] pren = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10001</span>];
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ends = <span class="hljs-number">0</span>, starts = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;
            <span class="hljs-keyword">if</span>(pren[num] &gt; starts) &#123;
                starts = pren[num];
            &#125;
            ends += num;
            pren[num] = ends;
            ans = Math.max(ans, ends - starts);
        &#125;

        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="1717-删除子字符串的最大得分">1717. 删除子字符串的最大得分</h1>
<p>20250723<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-score-from-removing-substrings/description/">题目链接</a></p>
<h2 id="思路-6">思路</h2>
<p>假设<span class="markdown-them-math-inline">$ab$</span>得分大于<span class="markdown-them-math-inline">$ba$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于每个只包含<span class="markdown-them-math-inline">$a$</span>和<span class="markdown-them-math-inline">$b$</span>的最长子串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从前向后遍历贪心更多的<span class="markdown-them-math-inline">$ab$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历结束后加上剩余的<span class="markdown-them-math-inline">$ba$</span></p>
<p>实现时用<span class="markdown-them-math-inline">$cl$</span>存储得分高的字符串的第一个字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用<span class="markdown-them-math-inline">$cr$</span>存储得分高的字符串的第二个字符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且使<span class="markdown-them-math-inline">$x$</span>为高分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$y$</span>为低分</p>
<p>假设<span class="markdown-them-math-inline">$ab$</span>得分更高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>遍历字符串<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设当前字符为<span class="markdown-them-math-inline">$b$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$a$</span>的数量大于<span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$a$</span>的数量减<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得分加<span class="markdown-them-math-inline">$x$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$a$</span>的数量为<span class="markdown-them-math-inline">$0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$b$</span>的数量加<span class="markdown-them-math-inline">$1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>字符为<span class="markdown-them-math-inline">$a$</span>的时候<span class="markdown-them-math-inline">$a$</span>的数量加<span class="markdown-them-math-inline">$1$</span></p>
<p>遍历到非<span class="markdown-them-math-inline">$a$</span>或<span class="markdown-them-math-inline">$b$</span>的字符时该字串结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>该子串必定只剩下<span class="markdown-them-math-inline">$b...ba...a(b \geq 0, a \geq 0)$</span>的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得分加上<span class="markdown-them-math-inline">$min(cnta, cntb) \times y$</span></p>
<h2 id="复杂度-4">复杂度</h2>
<ul>
<li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>遍历数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li>
<li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不需要额外空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(1)$</span></li>
</ul>
<h2 id="其他-3">其他</h2>
<p>遍历字符串的字符<br>
<code>for (char c : s.toCharArray())</code></p>
<h2 id="代码-6">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumGain</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> cntl = <span class="hljs-number">0</span>, cntr= <span class="hljs-number">0</span>;
        <span class="hljs-keyword">char</span> cl = x &gt; y ? <span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-string">&#x27;b&#x27;</span>;
        <span class="hljs-keyword">char</span> cr = x &gt; y ? <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-string">&#x27;a&#x27;</span>;
        <span class="hljs-keyword">int</span> t1 = Math.max(x, y);
        <span class="hljs-keyword">int</span> t2 = Math.min(x, y);
        x = t1;
        y = t2;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;
            <span class="hljs-keyword">if</span> (c == cl) &#123;
                cntl++;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == cr) &#123;
                <span class="hljs-keyword">if</span> (cntl == <span class="hljs-number">0</span>) &#123;
                    cntr++;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    ans += x;
                    cntl--;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                ans += Math.min(cntl, cntr) * y;
                cntl = <span class="hljs-number">0</span>;
                cntr = <span class="hljs-number">0</span>;
            &#125;
        &#125;
        ans += Math.min(cntl, cntr) * y;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;
</code></pre></div>
<hr>
<h1 id="2322-从树中删除边的最小分数">2322. 从树中删除边的最小分数</h1>
<p>20250724<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/description/">题目链接</a></p>
<h2 id="思路-7">思路</h2>
<p>前置知识<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>异或性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果<span class="markdown-them-math-inline">$a \oplus b = c$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则<span class="markdown-them-math-inline">$b \oplus c = a$</span></li>
<li>DFS时间戳<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>DFS遍历初始化<code>in</code>和<code>out</code>数组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果<code>i</code>是<code>j</code>的子节点则<span class="markdown-them-math-inline">$in[i] &gt; in[j]$</span>并且<span class="markdown-them-math-inline">$out[i] \leq out[j]$</span></li>
</ul>
<p>使用邻接表建(无向)图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>假设树以<span class="markdown-them-math-inline">$0$</span>为根,从<span class="markdown-them-math-inline">$0$</span>开始DFS整颗树并更新<code>in</code>和<code>out</code>数组,维护一个<code>xor</code>数组存储以<span class="markdown-them-math-inline">$i$</span>为根的子树的异或值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等于其本身的值与所有子树异或值的异或<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在DFS的同时可以完成</p>
<p>枚举除<span class="markdown-them-math-inline">$0$</span>以外的任意<span class="markdown-them-math-inline">$2$</span>个节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>删除它们与它们父节点之间的边<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>剩下的<span class="markdown-them-math-inline">$3$</span>个连通块有<span class="markdown-them-math-inline">$3$</span>种情况</p>
<p>假设<span class="markdown-them-math-inline">$2$</span>个节点分别为<span class="markdown-them-math-inline">$i$</span>和<span class="markdown-them-math-inline">$j$</span></p>
<ul>
<li><span class="markdown-them-math-inline">$i$</span>是<span class="markdown-them-math-inline">$j$</span>的子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以<span class="markdown-them-math-inline">$i$</span>为根的连通块的异或值为<span class="markdown-them-math-inline">$xor[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$j$</span>为根的连通块要排除以<span class="markdown-them-math-inline">$i$</span>为根的连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>异或值为<span class="markdown-them-math-inline">$xor[j] \oplus xor[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$0$</span>为根的连通块的要排除整个以<span class="markdown-them-math-inline">$j$</span>为根的子树<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>异或值为<span class="markdown-them-math-inline">$xor[0] \oplus xor[j]$</span></li>
<li><span class="markdown-them-math-inline">$j$</span>是<span class="markdown-them-math-inline">$i$</span>的子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与上一种类似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>三个连通块的异或值分别为<span class="markdown-them-math-inline">$xor[j]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span><span class="markdown-them-math-inline">$xor[i] \oplus xor[j]$</span>和<span class="markdown-them-math-inline">$xor[0] \oplus xor[i]$</span></li>
<li><span class="markdown-them-math-inline">$i$</span>和<span class="markdown-them-math-inline">$j$</span>互不为子节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以<span class="markdown-them-math-inline">$i$</span>为根的连通块的异或值为<span class="markdown-them-math-inline">$xor[i]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$j$</span>为根的连通块的异或值为<span class="markdown-them-math-inline">$xor[j]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>以<span class="markdown-them-math-inline">$0$</span>为根的连通块要排除以<span class="markdown-them-math-inline">$i$</span>为根的连通块和以<span class="markdown-them-math-inline">$j$</span>为根的连通块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>异或值为<span class="markdown-them-math-inline">$xor[0] \oplus xor[i] \oplus xor[j]$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
</ul>
<h2 id="复杂度-5">复杂度</h2>
<ul>
<li>时间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>枚举<span class="markdown-them-math-inline">$2$</span>个任意节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N ^ {2})$</span></li>
<li>空间复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>in</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>out</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>xor</code>等数组长度与节点数量相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N)$</span></li>
</ul>
<h2 id="其他-4">其他</h2>
<p>邻接表的定义及初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="highlight"><pre class="code"><code>List&lt;Integer&gt;[] g;
g = <span class="hljs-keyword">new</span> List[n];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
    g[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
&#125;
</code></pre></div>
<h2 id="代码-7">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> in[];
    <span class="hljs-keyword">int</span> out[];
    <span class="hljs-keyword">int</span> s[];
    List&lt;Integer&gt;[] g;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getres</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xo1, <span class="hljs-keyword">int</span> xo2, <span class="hljs-keyword">int</span> xo3)</span> </span>&#123;
        <span class="hljs-keyword">return</span> Math.max(xo1, Math.max(xo2, xo3)) - Math.min(xo1, Math.min(xo2, xo3));
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span>[][] edges)</span> </span>&#123;
        g = <span class="hljs-keyword">new</span> List[nums.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            g[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        &#125;
        in = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];
        out = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];
        s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.length; i++) &#123;
            g[edges[i][<span class="hljs-number">0</span>]].add(edges[i][<span class="hljs-number">1</span>]);
            g[edges[i][<span class="hljs-number">1</span>]].add(edges[i][<span class="hljs-number">0</span>]);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            s[i] = nums[i];
        &#125;
        dfs(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;
                <span class="hljs-keyword">if</span> (in[i] &gt; in[j] &amp;&amp; out[i] &lt;= out[j]) &#123;
                    ans = Math.min(ans, getres(s[i], s[j] ^ s[i], s[<span class="hljs-number">0</span>] ^ s[j]));
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in[j] &gt; in[i] &amp;&amp; out[j] &lt;= out[i]) &#123;
                    ans = Math.min(ans, getres(s[j], s[i] ^ s[j], s[<span class="hljs-number">0</span>] ^ s[i]));
                &#125; <span class="hljs-keyword">else</span> &#123;
                    ans = Math.min(ans, getres(s[i], s[j], s[<span class="hljs-number">0</span>] ^ s[i] ^ s[j]));
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;
        in[node] = clock++;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[node].size(); i++) &#123;
            <span class="hljs-keyword">if</span> (g[node].get(i) == fa) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            s[node] ^= dfs(g[node].get(i), node);
        &#125;
        out[node] = clock;
        <span class="hljs-keyword">return</span> s[node];
    &#125;
&#125;
</code></pre></div>
<hr>
<p>如有错误欢迎批评指正</p>
<p>部分思路来自Leetcode官方题解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>执行用时前排的代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>侵删</p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/06/11/comment-test/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          comment test
        
      </div>
    </a>
  
</nav>

  
</article>





  <section id="comments">
    <p>由于vercel.app域名被墙，可能无法查看和发送评论</p>
    <hr>
    <div id="waline"></div>
    <script type="module">
      import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

      init({
        el: '#waline',
        serverURL: 'https://waline-comment-black.vercel.app',
        lang: 'zh-CN',
        pageview: true,
        emoji: [
          'https://unpkg.com/@waline/emojis@1.1.0/weibo',
          'https://unpkg.com/@waline/emojis@1.1.0/tieba'
        ]
      });
    </script>
  </section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/24/leetcode-daily-20250718-20250724/">Leetcode Daily 20250718-20250724</a>
          </li>
        
          <li>
            <a href="/2025/06/11/comment-test/">comment test</a>
          </li>
        
          <li>
            <a href="/2025/06/10/password-test/">password test</a>
          </li>
        
          <li>
            <a href="/2025/06/08/test/">test</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Dave233<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/newmenu" class="mobile-nav-link">NewMenu</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>




<script src="/js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="/mathjax/tex-chtml.js">
</script>

  
<script src="/js/search.js"></script>

  
<link rel="stylesheet" href="/css/search.css">

<script>searchFunc('/search.xml', 'searchInput', 'searchResult');</script>
<!-- <script>$("#nav-search-btn").bind("click",searchFunc);</script> -->
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->



  </div>
  <div class="modal fade" id="searchModal">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-body">
                <i class="fa fa-search" aria-hidden="true"></i> 搜索
                <input type="text" class="form-control" id="searchInput" placeholder="Keyword">
                <div class="search-content" id="searchResult"></div>
            </div>
        </div>
    </div>
</div>

</body>
</html>